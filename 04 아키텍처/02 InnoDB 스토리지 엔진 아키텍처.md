# InnoDB 스토리지 엔진 아키텍처

![[innodb-architecture.png]]

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진중에서 거의 유일하게 레코드 기반의 잠금을 제공한다.  
이때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

## 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.    
즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며      
모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.   

프라이머리키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리된다.  
기본적으로 프라이머리키는 다른 인덱스에 비해 비중이 높게 설정되어 자주 사용될 가능성이 높다.  
 
InnoDB와 달리 MyISAM 스토리지 엔진에서는 클러스터링키를 지원하지 않는다.    
그래서 MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무 차이가 없다.    
그리고 MyISAM 테이블의 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값을 가진다.  

## 외래 키 지원 
외래키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다.
외래 키는 서비스의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않은 경우가 자주 있는데  
그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.  

InnoDB 에서 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고   
변경시에는 반드시 부모테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업도 필요하다.      
즉 **잠금이 여러 테이블로 전파되고, 그로인해 데드락이 발생할 때가 많으니 주의가 필요하다.**    

수동으로 데이터를 적재학나 스키마 변경등의 관리 작업이 실패할 수 있다.   
물론 관계를 파악하고 있으면 괜찮지만, 복잡하게 얽힐 경우 그렇게 간단하지 않다.   
또한 서비스에 문제가 있어서 긴급하게 뭔가 조치를 해야하는데 이런 문제가 발생하면 더 조급할 수 있다.  

* `foreign_key_checks` 시스템 변수를 OFF로 설정하면 
  외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
* 외래 키 관계를 멈추고 작업을 진행했다면 데이터 정합성을 위해 연관된 테이블에도 신경을 쓰자
* 참고로 위 명령어를 사용하면 부모 테이블에 대한 작업
  (ON DELETE CASCADE  / ON UPDATE CASCADE) 도 무시하게 된다. 

## MVCC
레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.  
MVCC의 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다.**  

InnoDB는 `UnDO 로그`를 이용해 이 기능을 구현했다.    
MVCC의 멀티 버전은 하나의 레코드에 대해 여러개의 버전이 동시에 관리된다는 의미이다.  

이해를 위해 격리 수준이 READ_COMMITED 인 MySQL 서버에서
InnoDB 스터리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 살펴보자.   

![[images_fortice_post_f3b40a28-14d1-4ff6-85f6-1f1648c0ec77_image.png]]

UPDATE 문장이 실행되면   
커밋 실행 여부와 관계 없이 InnoDB의 버퍼 풀은 새로운 값으로 업데이트 된다.  
그리고 디스크의 데이터 파일에는 체크 포인트나 InnoDB 의 Write 쓰레드에 의해 
새로운 값으로 업데이트 될수도 있고 아닐 수도 있다.   

아직 COMMIT 이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 작업중인 레코드를 조회하면?   
격리수준마다 다르게 결과값이 나온다.  

ReadUncommitted 는 버퍼풀이 현재 가지고 있는 값(변경 된 값)을 읽어서 반환한다.   
ReadCommitted 이상의 격리수준인 경으 언두 영역의 데이터를 반환한다.   
이러한 과정을 DBMS에서는 MVCC 라고 표현한다.  

즉 하나의 레코드에 대해서 2개의 버전이 유지되고,   
필요에 따라 어느 데이터가 보여지는지 여러가지 상황에 따라 달라지는 구조다.   
(정확히 말하면 write-lock/write-lock 구조가 락 구성시 대기를 최소화 하도록 하는것)

즉, 새로운 데이터로 변경이 이루어지면 
버퍼 풀에 있는 데이터가 언두 영역으로 옮겨지고 
COMMIT 시 InnoDB 버퍼풀에 데이터(변경된)가 영구 저장
ROLLBACK시 언두 영역 데이터로 InnoDB 버퍼풀로 복구 하는 것을 알 수 있다.   
  
하지만, 커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다.   
이 언두 영역을 필요로하는 틀내잭션이 더는 없을 때 비로소 삭제된다.  

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 실행한다.    
즉, 다른 트랜잭션에서 락이 발생해도 `읽기`에 한하여 잠금 대기를 하지 않고 데이터를 읽어올 수 있는 형태다.    
  
격리수준이 SERIALIZABLE 이 아닌   
READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준인 경우   
INSERT 와 연결되지 않은 순수한 읽기 작업은   
다른 트랜잭션의 변경 작업과 관계없이 잠금을 대기하지 않고 실행된다.     
(SERIALIZABLE 은 읽기시 Select for update 를 이용해 락을 걸기 때문에 MVCC 매커니즘과 다르다.)      
  
쓰기 입장에서도    
아직 커밋을 수행하지 않았다 하더라도 다른 사용자의 SELECT 작업을 방해하지 않는다.     
이를 `잠금 없는 일관된 읽기`라고 표현하며    
InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두로그를 사용한다.  

오랜 시간동안 호라성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 있는데      
바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문에 발생하는 문제이다.      
따라서 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.   
 
## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착상태에 빠지지 않았는지 체크하기 위해    
잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.    
   
InnoDB 스토리지 엔진ㅇ느 데드락 감지 스레드를 가지고 있어      
데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 종료시킨다.       
종료되는 트랜잭션 선정 기준은 언두 로그의 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백 대상이 된다.  
(데이터 적으며, 롤백 부하도 덜 유발)   

참고로 InnoDB는 상위 엔진인 MySQL엔진에서 관리되는 테이블 잠금을 볼수 없어 데드락 감지가 불확실할 수 있는데     
innodb_table_lock 시스템 변수를 활성화하면, 테이블 레벨까지도 감지할 수 있어서 이를 설정해주자  




InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 실행한다.    ㅈㅗㄹ
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 실행한다.   ㅇ료
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 실행한다.    
