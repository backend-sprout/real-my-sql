# MySQL 로그 파일

MySQL 서버에서 서버의 상태를 진단할 수 있는 많은 도구들이 지원되지만 많은 지식을 필요로하는 경우가 많다.           
MySQL 로그 파일을 이용하면 깊은 내부 지식이 없어도 MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아서 해결할 수 있다.    

## 에러 로그 파일 
MySQL 이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그파일이다.     
에러 로그 파일의 위치는 MySQL 설정 파일(my.cnf)애서 log_error 파라미터에 정의된 경로에 생성된다.    
MySQL 설정 파일에 별도로 정의되지 않은 경우, 데이터 디렉터리에 .err 라는 확장자가 붙은 파일로 생성된다.       

### MySQL 이 시작하는 과정과 관련된 정보성 및 에러 메시지 

MySQL 설정 파이을 변경하거나 데이터베이스가 비정상적으로 종료된 이후 다시 시작하는 경우      
반드시 MySQL 에러 로그 파일을 통해 설정된 변수의 이름이나 값이 명확하게 설정되고 의도한대로 적용됐는지 확인해야한다.      

MySQL 서버가 정상적으로 기동되었고, 새로 변경하거나 추가한 파라미터에 대해 에러나 경고성 메시지가 없다면 정상적 적용으로 판단한다.     
그렇지 않고 특정 변수가 무시된 경우에는 MySQL 서버는 정상적으로 기동하지만 해당 파라미터는 MySQL에 적용되지 못했음을 의미한다.     
그리고 변수명을 인식하지 못하거나 설정된 파라미터 값의 내용을 인식하지 못하는 경우에는       
MySQL 서버가 에러 메시지를 출력하고 시작하지 못했다는 메시지를 보여준다.     

### 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB 트랜잭션 복구 메시지  

InnoDB의 경우에는 MySQL 서버가 비정상적 또는 강제적으로 종료됐다면     
다시 시작되면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 하게된다.     
이 과정에서 간단한 메시지가 출력되는데 문제가 있는 경우 에러 메시지를 출력하고 MySQL을 종료시킨다.    
이때 '복구'에서 보았던 innodb_force_recovery 레벨을 조정하며 안될경우 복사나 덤프로 복구해야한다.  

### 쿼리 처리 도중 발생하는 문제에 대한 에러 메시지    

쿼리 도중 발생하는 문제점은 사전 예방이 어려우며, 주기적으로 에러 로그 파일을 검토하는 과정에서 알게된다.        
쿼리의 실행 도중 발생한 에러나 복제에서 문제가 될만한 쿼리에 대한 경고 메시지가 에러 로그에 남게 된다.        
그래서 자주 에러 로그 파일을 검토하는 것이 데이터베이스의 숨겨진 문제점을 해결하는데 많은 도움이 될 것이다.    

### 비정상적으로 종료된 커넥션 메시지(Aborted connection)    

어떤 데이터베이스 서버의 로그 파일을 보면 이 메시지가 상당히 많이 누적되어있는 경우가 있다.   
클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 
MySQL 의 에러 로그 파일에 이런 내용이 기록된다. (네트워크 통신 문제 발생시에도 출력)   
  
max_connect_errors 시스템 변숫값이 너무 낮게 설정된 경우      
클라이언트 프로그램이 MySQL 서버에 접속하지 못하고 에러가 발생할 수 있다.  

이 메시지는 클라이언트 호스트에서 발생한 에러의 횟수가 max_connect_errors 변수의 값을 넘게되면 발생하는데   
이 경우 max_connect_errors 값을 증가시키면 된다.(이전에 왜 에러가 발생했는지 파악이 우선이다.)    

### InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은) 메시지
  
InnoDB 테이블 모니터링이나 락 모니터링 또는 InnoDB의 엔진 상태를 조회하는 명령은 상대적으로 큰 메시지를 에러 로그 파일에 기록한다.       
InnoDB 의 모니터링을 할성화 상태로 만들어 두고 그대로 유지하는 경우에는    
에러 로그 파일이 매우 커져서 파일 시스템의 공간을 다사용해 버릴지도 모른다.    
모니터링을 사용한 이후에는 다시 비활성화해서 에러 로그 파일이 커지지 않게 만들어야한다.   

### MySQL 종료 메시지 
 
가끔 MySQL이 종료돼 있거나 재시작된 경우가 있다.       
이러한 경우 에러 로그 파일에서 MySQL 이 마지막으로 종료되면서 출력한 메시지를 확인하는 것이 종료를 확인하는 유일한 방법이다.     

누군가가 종료했다면 `Received SHUTDOWN from user...` 라는 메시지를 확인할 수 있다.   
그렇지 않으면 MySQL 서버가 세그먼테이션 폴트로 비정상적으로 종료된 것으로 판단할 수 있다.  
세그먼트 폴트로 종료된 경우에는 스택 트레이스의 내용을 최대한 참조해서 MySQL의 버그와 연관이 있는지 조사한 후   
MySQL의 버전을 업그레이드하거나 회피책을 찾는 것이 최적의 방법이다.   

## 제너럴 쿼리 로그 파일(제너럴 로그 파일, General Log)

가끔 MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체목록을 뽑아서 검토해볼때가 있는데      
이때는 쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일로 기록하게 한 다음, 그파일을 검토하면 된다.     
  
쿼리로그 파일에는 다음과 같이 시간 단위로 실행됐던 쿼리의 내용이 모두 기록된다.     
슬로우 쿼리 로그와는 조금 다르게 제너럴 쿼리 로그는 실행되기 전에 MySQL이 쿼리 요청을 받으면     
바로 기록하기 때문에 쿼리 실행중에 에러가 발생해도 일단 로그 파일에 기록된다.    

```
SHOW GLOBAL VARIABLES LIKE 'general_log_file'
```

쿼리 로그 파일의 경로는 `gerneral_log_file` 이라는 이름의 파라미터에 설정돼 있다.        
또한 쿼리 로그를 파일이 아닌 테이블에 저장하도록 설정할 수 있으므로 이 경우에는 파일이 아닌 테이블을 SQL로 조회해서 검토한다.    
쿼리 로그 파일로 저장할지 테이블로 저장할지는 log_output 파라미터로 결정된다.      

## 슬로우 쿼리 로그 

MySQL의 서버 쿼리 튜닝은 크게 아래로 나눌 수 있다.    
1. 서비스가 적용되기 전에 전체적으로 튜닝   
2. 서비스 운영중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝  
  
후자의 경우, 쿼리외적으로도 판단할 요소가 많은데 `슬로우 쿼리 로그`를 사용하면 쿼리문제인지 판단이 가능하다.   

슬로우 쿼리 로그 파일에는 long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다.     
단, 반드시 쿼리가 정상적으로 실행이 완려된 경우에만 로그에 기록할 수 있다.     

log_output 옵션을 이용해 슬로우 쿼리 로그를 파일로 기록할지 테이블로 기록할지 선택할 수 있다.   

* log_output 옵션 TABLE : 제너럴 로그나 슬로우 쿼리 로그를 mysql DB의 테이블(general_log 와 slow_log 테이블)에 저장하며,     
* log_output 옵션 FILE : 설정하면 로그의 내용을 디스크 파일로 저장한다.      
  
MySQL 잠금 처리는 MySQL 엔진 레벨과 스토리지 엔진 레벨의 두가지 레이어로 처리되는데       
MyISAM 이나 MEMORY 스토리지 엔진과 같은 경우에는 별도의 스토리지 엔진 레벨의 잠금을 가지지 않지만       
InnoDB의 경우 MySQL 엔진 레벨의 잠금과 스토리지 엔진 자체 잠금을 가지고 있다.      
이러한 이유로 슬로우 쿼리 로그에 출력되는 내용이 상당히 혼란스러울 수 있다.   

```
```
* 'Time' 항목 : 
  쿼리가 시작된 시간이 아니라 쿼리가 종료된 시점을 의미한다.   
  그래서 쿼리가 언제 시작됐는지 확인하려면 'Time' 항목에 나온 시간에서 'Query_time'만큼 빼야한다.   
* 'User@Host' 항목 :    
  쿼리 실행한 사용자의 계정이다.   
* 'Query_time' 항목 :
  쿼리가 실행되는데 걸린 전체 시간을 의미한다.      
  'Lock_time'은 사실 위 2가지 레벨 잠금 가운데 MySQL 엔진 레벨에서 관장하는 테이블 자금에 대한 대기 시간만 표현한다.   
  'Lock_time'에 표기된 시간은 실제 쿼리가 실행되는 데 필요한 잠금 체크와 같은 코드 실행 부분의 시간까지 모두 포함된다.   
* 'Rows_examined' 항목 : 
  이 쿼리가 처리되기 위해 몇건의 레코드에 접근했는지를 의미한다.   
  일반적으로 'Rows_examined'의 레코드 건수는 높지만   
  'Rows_sent'에 표시된 건수가 상당히 적다면 이 쿼리는 조금 더 적은 레코드만 접근하도록 튜닝해볼 가치는 있다.   
      
MyISAM 이나 MEMORY 스토리지 엔진에서는 테이블 단위의 잠금을 사용하고         
MVCC와 같은 메커니즘이 없기 때문에 SELECT 쿼리라고 하더라도 Lock_time 이 1초 이상 소요될 가능성이 있다.        
InnoDB 스토리지 엔진에서는 가끔 상대적으로 큰 값이 발생할 수 있는데, MySQL 엔진 레벨에서 설정한 테이블 잠금 때문일 가능성이 높다.     
그래서 InnoDB 테이블에만 접근하는 쿼리 문장의 슬로우 쿼리 로그에는 Lock_time 값은 튜닝이나 쿼리 분석에 별로 도움이 되지 않는다.   
  
일반적으로 슬로우 쿼리 또는 제너럴 로그 파일의 내용이 상당히 많아서         
직접 쿼리를 하나씩 검토하기에는 시간이 너무 많이 걸리거나 어느 쿼리를 집중적으로 튜닝해야할지 식별하기가 어려울 수 있다.      
이런 경우에는 Percona에서 개발한 Percona Toolkit의 pt-query-digest 스크립트를 이용하면 쉽게 빈도나 처리 성능 별로 쿼리를 정렬해서 살펴볼 수 있다.    

### 슬로우 쿼리 통계 
 
분석 결과의 최상단에 표시되며, 모든 쿼리를 대상으로   
슬로우 쿼리 로그의 실행시간(Exec time)     
그리고 잠금 대기시간(Lock time)등에 대해 평균 및 최소/최대값을 표시한다.    

### 실행 빈도 및 누적 실행 시간순 랭킹 

각 쿼리별로 응답 시간과 실행 횟수를 보여주는데, `pt-query-digest` 명령 실행시, `--order-by` 옵션으로 정렬 순서를 변경할 수 있다.        
Query ID는 실행된 쿼리 문장을 정규화해서 만들어진 해시 값을 의미하는데, 일반적으로 같은 모양의 쿼리라면 동일한 Query ID를 가지게 된다.     

### 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보 

Query ID별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여준다.       
랭킹별 쿼리에서는 대상 테이블에 대해 어떤 쿼리인지만을 표시하는데        
실제 상세한 쿼리 내용은 각 개별 쿼리의 정보를 확인해보면 된다.     

여기서는 쿼리가 얼마나 실행됐는지, 쿼리의 응답시간에 대한 히스토그램 같은 상세한 내용을 보여준다.   


  
  
  
    
    















